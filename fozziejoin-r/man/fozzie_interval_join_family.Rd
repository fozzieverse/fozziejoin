% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fozzie_interval_join.R
\name{fozzie_interval_join_family}
\alias{fozzie_interval_join_family}
\alias{fozzie_interval_join}
\alias{fozzie_interval_inner_join}
\alias{fozzie_interval_left_join}
\alias{fozzie_interval_right_join}
\alias{fozzie_interval_full_join}
\alias{fozzie_interval_anti_join}
\alias{fozzie_interval_semi_join}
\title{Perform a fuzzy join between two data frames using interval overlap matching.}
\usage{
fozzie_interval_join(
  df1,
  df2,
  by = NULL,
  how = "inner",
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = c("auto", "real", "integer"),
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_interval_inner_join(
  df1,
  df2,
  by = NULL,
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = "auto",
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_interval_left_join(
  df1,
  df2,
  by = NULL,
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = "auto",
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_interval_right_join(
  df1,
  df2,
  by = NULL,
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = "auto",
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_interval_full_join(
  df1,
  df2,
  by = NULL,
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = "auto",
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_interval_anti_join(
  df1,
  df2,
  by = NULL,
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = "auto",
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_interval_semi_join(
  df1,
  df2,
  by = NULL,
  overlap_type = "any",
  maxgap = 0,
  minoverlap = 0,
  interval_mode = "auto",
  nthread = getOption("fozzie.nthread", NULL)
)
}
\arguments{
\item{df1}{A data frame to join from (left table).}

\item{df2}{A data frame to join to (right table).}

\item{by}{A named list mapping left and right interval columns. Must contain two entries: start and end.}

\item{how}{A string specifying the join mode. One of:
\itemize{
\item \code{"inner"}: matched pairs only.
\item \code{"left"}: all rows from \code{df1}, unmatched rows filled with NAs.
\item \code{"right"}: all rows from \code{df2}, unmatched rows filled with NAs.
\item \code{"full"}: all rows from both \code{df1} and \code{df2}.
\item \code{"anti"}: rows from \code{df1} not matched in \code{df2}.
\item \code{"semi"}: rows from \code{df1} that matched with one or more matches in \code{df2}.
}}

\item{overlap_type}{A string specifying the overlap logic. One of:
\itemize{
\item \code{"any"}: any overlap.
\item \code{"within"}: left interval fully within right.
\item \code{"start"}: left start within right.
\item \code{"end"}: left end within right.
}}

\item{maxgap}{Maximum allowed gap between intervals (non-negative).}

\item{minoverlap}{Minimum required overlap length (non-negative).}

\item{interval_mode}{A string specifying how interval boundaries should be interpreted. One of:
\itemize{
\item \code{"auto"}: automatically infer mode based on column types.
\item \code{"real"}: treat interval boundaries as continuous numeric values (e.g., \code{double}). Overlaps are computed using strict inequality and floating-point arithmetic.
\item \code{"integer"}: treat interval boundaries as discrete integer ranges. This mode behaves similarly to Bioconductor's \code{IRanges} â€” intervals are inclusive and defined over integer coordinates, so \verb{[start, end]} includes both endpoints. This affects how overlaps, gaps, and minimum overlap lengths are calculated, especially when \code{maxgap} or \code{minoverlap} are used.
}}

\item{nthread}{Optional integer specifying the number of threads to use for
parallelization. If not provided, the value is determined by
\code{options("fozzie.nthread")}. The package default is inherited from
Rayon, the multithreading library used throughout the package.}
}
\value{
A data frame with approximately matched rows depending on the join type.
}
\description{
\code{fozzie_interval_join()} and its directional variants (\code{fozzie_interval_inner_join()}, \code{fozzie_interval_left_join()}, etc.)
enable approximate matching of interval columns in two data frames based on overlap logic.
These joins are conceptually similar to \code{data.table::foverlaps()} and Bioconductor's \code{IRanges::findOverlaps()}, supporting both continuous and discrete interval semantics.
}
\note{
When \code{interval_mode = "real"}, interval boundaries are treated as continuous values and matched using floating-point arithmetic.
Due to precision limitations, a small threshold (typically around \code{1e-6}) is internally added to the query range to ensure adjacent or near-touching intervals are considered for matching.
This is especially relevant for timestamp-based joins, where intervals like \verb{[14:00:00, 14:00:01]} and \verb{[13:00:00, 14:00:00]} may fail to match unless a sufficient \code{maxgap} or internal epsilon is applied.
}
\examples{
df1 <- data.frame(start = c(1, 5), end = c(3, 7))
df2 <- data.frame(start = c(2, 6), end = c(4, 8))

fozzie_interval_inner_join(df1, df2, by = c(start = "start", end = "end"), overlap_type = "any")
}
