% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fozzie_string_join.R
\name{fozzie_string_join_family}
\alias{fozzie_string_join_family}
\alias{fozzie_string_join}
\alias{fozzie_string_inner_join}
\alias{fozzie_string_left_join}
\alias{fozzie_string_right_join}
\alias{fozzie_string_anti_join}
\alias{fozzie_string_full_join}
\alias{fozzie_string_semi_join}
\title{Perform a fuzzy join between two data frames using approximate string matching.}
\usage{
fozzie_string_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  how = "inner",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_string_inner_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_string_left_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_string_right_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_string_anti_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_string_full_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)

fozzie_string_semi_join(
  df1,
  df2,
  by = NULL,
  method = "levenshtein",
  max_distance = 1,
  distance_col = NULL,
  q = NULL,
  max_prefix = 0,
  prefix_weight = 0,
  nthread = getOption("fozzie.nthread", NULL)
)
}
\arguments{
\item{df1}{A data frame to join from (left table).}

\item{df2}{A data frame to join to (right table).}

\item{by}{A named list or character vector indicating the matching columns. Can be a character vector of length 2, e.g. \code{c("col1", "col2")},
or a named list like \code{list(col1 = "col2")}.}

\item{method}{A string indicating the fuzzy matching method. Supported methods:
\itemize{
\item \code{"levenshtein"}: Levenshtein edit distance (default).
\item \code{"osa"}: Optimal string alignment.
\item \code{"damerau_levensthein"} or \code{"dl"}: Damerau-Levenshtein distance.
\item \code{"hamming"}: Hamming distance (equal-length strings only).
\item \code{"lcs"}: Longest common subsequence.
\item \code{"qgram"}: Q-gram similarity (requires \code{q}).
\item \code{"cosine"}: Cosine similarity (requires \code{q}).
\item \code{"jaccard"}: Jaccard similarity (requires \code{q}).
\item \code{"jaro"}: Jaro similarity.
\item \code{"jaro_winkler"} or \code{"jw"}: Jaro-Winkler similarity.
\item \code{"soundex"}: Soundex codes based on the National Archives standard.
}}

\item{how}{A string specifying the join mode. One of:
\itemize{
\item \code{"inner"}: matched pairs only.
\item \code{"left"}: all rows from \code{df1}, unmatched rows filled with NAs.
\item \code{"right"}: all rows from \code{df2}, unmatched rows filled with NAs.
\item \code{"full"}: all rows from both \code{df1} and \code{df2}.
\item \code{"anti"}: rows from \code{df1} not matched in \code{df2}.
\item \code{"semi"}: rows from \code{df1} that matched with one or more matches in \code{df2}.
}}

\item{max_distance}{A numeric threshold for allowable string distance or dissimilarity (lower is stricter).}

\item{distance_col}{Optional name of column to store computed string distances.}

\item{q}{Integer. Size of q-grams for \code{"qgram"}, \code{"cosine"}, or \code{"jaccard"} methods.}

\item{max_prefix}{Integer (for Jaro-Winkler) specifying the prefix length influencing similarity boost.}

\item{prefix_weight}{Numeric (for Jaro-Winkler) specifying the prefix weighting factor.}

\item{nthread}{Optional integer specifying the number of threads to use for
parallelization. If not provided, the value is determined by
\code{options("fozzie.nthread")}. The package default is inherited from
Rayon, the multithreading library used throughout the package.}
}
\value{
A data frame with fuzzy-matched rows depending on the join type. See individual functions like \code{fozzie_string_inner_join()} for examples.
If \code{distance_col} is specified, an additional numeric column is included.

See \code{\link[=fozzie_string_join]{fozzie_string_join()}}

See \code{\link[=fozzie_string_join]{fozzie_string_join()}}

See \code{\link[=fozzie_string_join]{fozzie_string_join()}}

See \code{\link[=fozzie_string_join]{fozzie_string_join()}}

See \code{\link[=fozzie_string_join]{fozzie_string_join()}}

See \code{\link[=fozzie_string_join]{fozzie_string_join()}}
}
\description{
\code{fozzie_string_join()} and its directional variants (\code{fozzie_string_inner_join()}, \code{fozzie_string_left_join()}, \code{fozzie_string_right_join()}, \code{fozzie_string_anti_join()}, \code{fozzie_string_full_join()})
enable approximate matching of string fields in two data frames. These joins support multiple string distance
and similarity algorithms including Levenshtein, Jaro-Winkler, q-gram similarity, and others.
}
\examples{
df1 <- data.frame(name = c("Alice", "Bob", "Charlie"))
df2 <- data.frame(name = c("Alicia", "Robert", "Charles"))

fozzie_string_inner_join(
  df1, df2, by = c("name"), method = "levenshtein", max_distance = 2
)
fozzie_string_left_join(
  df1, df2, by = c("name"), method = "jw", max_distance = 0.2
)
fozzie_string_right_join(
  df1, df2, by = c("name"), method = "cosine", q = 2, max_distance = 0.1
 )

}
